import datetime

from django.db import models
from django.utils.timezone import make_aware

from people.models import Child, Classroom
from main.model_fields import WeekdayField, NumChoiceField, WEEKDAYS
from main.utilities import WeekdayIterator, next_date_with_given_weekday

from people.views import ClassroomMixin

# what if family has two kids in one classroom?
# one (end-user) solution is to apportion all worktime obligations to one of them

"""
for generic __str__ method:
str_attrs_list = ['attr1', 'attr2']
str_attrs = ",".join([f"{attr}={getattr(self, attr)}" for attr in self.display_attrs])
return f"<{self.__class__.__name__} {self.pk}: " + str_attrs + ">"
"""


class Holiday(models.Model):
    name = models.CharField(max_length=50)
    start_date = models.DateField()
    end_date = models.DateField(null=True)
    
    def save(self, *args, **kwargs):
        self.end_date = self.end_date or self.start_date
        super().save(*args, **kwargs)

    def __str__(self):
        end = '-'.append(self.end_date) if self.end_date != self.start_date else ''
        return f"{self.name} ({self.start_date}{end})"

class Happening(models.Model):
    name = models.CharField(max_length=50)
    description = models.TextField()
    start_date = models.DateField()
    start_time = models.TimeField(null=True)
    end_time = models.TimeField(null=True)
    

class Period(models.Model):
    classroom = models.ForeignKey(Classroom, on_delete=models.CASCADE)
    start_date = models.DateField()
    duration = models.DurationField(default=datetime.timedelta(days=7*4*4))

    @property
    def end_date(self):
        # do this with query
        return self.start_date + self.duration

    def __str__(self):
        return f"<Period {self.pk}: {self.start_date} - {self.end_date}>"


class TimeSpan(models.Model):
    # name = models.CharField(max_length=32)
    start_time = models.TimeField()
    end_time = models.TimeField()

    class Meta:
        ordering = ['start_time']
        abstract = True


class CareDay(TimeSpan):
    weekday = WeekdayField()
    extended_endtime = models.TimeField()

    @property
    def shifts(self):
        return Shift.objects.filter(weekday=self.weekday, 
                                    start_time__gte=self.start_time,
                                    end_time__lte=self.end_time)

    def __repr__(self):
        return f"<CareDay {self.pk}: weekday={self.weekday}, start_time={self.start_time}, end_time={self.end_time}>"


# """
# this and and also shiftinstance should be virtual (generated by shift, careday)
# """
# # is this in use???
# class CareDayInstance(models.Model):
#     care_day = models.ForeignKey(CareDay, null=True, on_delete=models.CASCADE)
#     date = models.DateField()

#     def shift_instances(self):
#         return ShiftInstance.objects.filter(date=self.date)
    

# normalize between extended and end_time?
class CareDayAssignment(models.Model):
    child = models.ForeignKey(Child, on_delete=models.CASCADE) 
    weekday = WeekdayField()
    extended = models.BooleanField(default=False)
    start_time = models.TimeField(default=datetime.time(8,30))
    end_time = models.TimeField(default=datetime.time(15,30))
    
    def __repr__(self):
        return f"<{self.__class__.__name__} {self.pk}>: child={self.child}, weekday={self.weekday}, start_time={self.start_time}, end_time={self.end_time}"

    def save(self, *args, **kwargs):
        if self.extended == True:
            self.end_time = datetime.time(17, 30)
        super().save(*args, **kwargs)


class ExtraCareDay(models.Model):
    child = models.ForeignKey(Child, on_delete=models.CASCADE)
    date = models.DateField()
    extended = models.BooleanField(default=False)
    start_time = models.TimeField(default=datetime.time(8,30))


class CancelledCareDay(models.Model):
    child = models.ForeignKey(Child, on_delete=models.CASCADE)
    date = models.DateField()


# todo how about adding/deleting late stay?

"""
given caredaycontracts of child, access its possible shifts
conversely, access children from shift
"""


###################################
# worktime shifts  and assignments #
###################################


class Shift(TimeSpan):
    # add foreignkey to classroom
    weekday = WeekdayField()

    def next_instance_from(self, from_date):
        # offset = (int(self.weekday) - period.start_date.weekday()) % 7        
        instance_date = next_date_with_given_weekday(int(self.weekday), from_date)
        return datetime.datetime.combine(instance_date, self.start_time)

    def create_instances_in_period(self, period):
        wi = WeekdayIterator(self.next_instance_from(period.start_date))
        for k in range(period.duration.days // 7):
            if not Holiday.objects.filter(start_date__lte=wi[k],
                                          end_date__gte=wi[k]):
                ShiftInstance.objects.get_or_create(date=wi[k],
                                                    shift=self,
                                                    classroom=period.classroom)

    def instances_in_period(self, period):
        return ShiftInstance.objects.filter(shift=self,
                                            date__gte=period.start_date,
                                            date__lte=period.start_date+period.duration)
    @property
    def children(self):
        return Child.objects.filter(caredaycontract__careday__shifts__contains=self)

    @property
    def care_day(self):
        return CareDay.objects.get(weekday=self.weekday,
                                   start_time__lte=self.start_time,
                                   end_time__gte=self.end_time)

    def __repr__(self):
        return f"<Shift {self.pk}: weekday={self.weekday}, time={self.start_time}>"

    def __str__(self):
        return f"{WEEKDAYS[self.weekday]} {self.start_time}"

    class Meta:
        ordering = ['weekday', 'start_time']


# remove the shift attribute
class ShiftInstance(models.Model):
    shift = models.ForeignKey(Shift, null=True, on_delete=models.CASCADE)
    start_time = models.TimeField()
    end_time = models.TimeField()
    date = models.DateField()
    commitment = models.ForeignKey(Child, null=True, blank=True,
                                   on_delete=models.SET_NULL)
    classroom = models.ForeignKey(Classroom, on_delete=models.CASCADE)

    def save(self, *args, **kwargs):
        if not self.pk:
            self.start_time = self.shift.start_time
            self.end_time = self.shift.end_time
        super().save(*args, **kwargs)
    

    def __str__(self):
        return f"{self.shift}, {self.date}"

    class Meta:
        ordering = ['date', 'shift']


class ShiftPreference(models.Model):
    family = models.ForeignKey(Child, on_delete=models.CASCADE)
    shift = models.ForeignKey(Shift, on_delete=models.CASCADE)
    rank = NumChoiceField()
    def __repr__(self):
        return f"<ShiftPreference {self.pk}: {self.family} ranks {self.shift} as {self.rank}>"


# could be called shiftassignment
class WorktimeAssignment(models.Model):
    family = models.ForeignKey(Child, on_delete=models.CASCADE)
    period = models.ForeignKey(Period, on_delete=models.CASCADE)
    shift = models.ForeignKey(Shift, on_delete=models.CASCADE)
    def __repr__(self):
        return f"<WorktimeAssignment {self.pk}: {self.family} assigned {self.shift} in period {self.period}>"


# class WorktimeCommitment(models.Model):
#     family = models.ForeignKey(Child, on_delete=models.CASCADE)
#     shift_instance = models.ForeignKey(ShiftInstance, on_delete=models.CASCADE)

#     @property
#     def date(self):
#         return self.shift_instance.date

#     @property
#     def start_time(self):
#         return self.shift_instance.start_time

#     @property
#     def end_time(self):
#         return self.shift_instance.end_time

#     def __repr__(self):
#         return f"<WorktimeCommitment {self.pk}: {self.family} has {self.shift_instance}>"

#     class Meta:
#         ordering = ['shift_instance']


# class ClassroomWorktimeMixin(object):
 
#     def shifts_dict(self, date, classroom=None):
#         classroom = classroom or self.classroom
#         return {shift_instance:
#                 shift_instance.commitment
#                 for shift_instance in ShiftInstance.objects.filter(date=date)}

#     def days_dict(self, start_date, num_days, classroom=None):
#         classroom = classroom or self.classroom
#         return {date: self.shifts_dict(date, classroom=classroom)
#                 for date in [start_date + datetime.timedelta(days=n)
#                              for n in range(num_days)]}

#     def weeks_list(self, start_date, num_weeks, classroom=None):
#         classroom = classroom or self.classroom
#         return [self.days_dict(date, 5, classroom=classroom)
#                 for date in [start_date + n * datetime.timedelta(days=7)
#                              for n in range(num_weeks)]]
